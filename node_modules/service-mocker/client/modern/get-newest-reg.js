"use strict";
var tslib_1 = require("tslib");
var _1 = require("../../utils/");
var updateLog = _1.debug.scope('update');
/* istanbul ignore next: unable to test it on single run */
function getNewestReg() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var serviceWorker, registration, newWorker;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    serviceWorker = navigator.serviceWorker;
                    updateLog.color('darkorchid').info('checking for updates');
                    return [4 /*yield*/, serviceWorker.getRegistration()];
                case 1:
                    registration = _a.sent();
                    if (!registration) {
                        throw new Error('no active service worker registration is found');
                    }
                    // reg.update() resolved with `reg.installing` set when updates are found, see
                    // #10 in https://w3c.github.io/ServiceWorker/#update-algorithm
                    // #4 and #7 in https://w3c.github.io/ServiceWorker/#installation-algorithm
                    return [4 /*yield*/, registration.update()];
                case 2:
                    // reg.update() resolved with `reg.installing` set when updates are found, see
                    // #10 in https://w3c.github.io/ServiceWorker/#update-algorithm
                    // #4 and #7 in https://w3c.github.io/ServiceWorker/#installation-algorithm
                    _a.sent();
                    newWorker = registration.installing || registration.waiting;
                    if (!newWorker) return [3 /*break*/, 4];
                    updateLog.info('installing updates');
                    // wait until worker is activated
                    return [4 /*yield*/, _1.eventWaitUntil(newWorker, 'statechange', function () { return newWorker.state === 'activated'; })];
                case 3:
                    // wait until worker is activated
                    _a.sent();
                    return [3 /*break*/, 5];
                case 4:
                    updateLog.color('lightseagreen').info('already up-to-date');
                    _a.label = 5;
                case 5: return [2 /*return*/, registration];
            }
        });
    });
}
exports.getNewestReg = getNewestReg;
//# sourceMappingURL=get-newest-reg.js.map