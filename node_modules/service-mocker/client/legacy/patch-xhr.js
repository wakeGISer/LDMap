/**
 * Patch native `XMLHttpRequest`
 *
 * Notes:
 * - When and how to dispatch fetch event:
 *   1. A XMLHttpRequest won't be sent until we call `xhr.send()`, so we should dispatch a
 *   fetch event when `xhr.send()` is invoked,
 *   2. By overriding `xhr.open()` method, we can get `request_method` and `request_url`,
 *   3. By overriding `xhr.setRequestHeader()`, we can get `request_headers`,
 *   4. Create a request instance with `request_method`, `request_url`, `request_headers`,
 *      and other options got from `this[xhrProp]` like `this.withCredentials` (will be
 *      delegated to `this.nativeXHR[xhrProp]`).
 *   5. Dispatch fetch event with the request.
 *   6. If fetch event responds with a `Response`, parse it and dispatch `readystatechange`
 *      event and progress events via `this.dispatchEvent()` (will be delegated to
 *      `this.nativeXHR.dispatchEvent()`).
 *   7. Or, re-send native requeust via `this.nativeXHR.send()`.
 *
 * - About events handling:
 *   1. Since we delegate all `XMLHttpRequest.prototype` methods to `this.nativeXHR`, there's
 *   no need to create an event emitter, simply calling `this.dispatchEvent()` and all
 *   registered listeners will be invoked, including those are set by `instance#on[event]`.
 *   2. Meanwhile, all the event handlers you registered on `ExtandableXHR` instance will actually be
 *   registered on `this.nativeXHR`. So even if we re-send the native request, all the handlers will
 *   be called properly.
 */
"use strict";
var tslib_1 = require("tslib");
var create_event_1 = require("./create-event");
var dispatch_fetch_event_1 = require("./dispatch-fetch-event");
var _1 = require("../../utils/");
function patchXHR() {
    if (XMLHttpRequest.mockerPatched) {
        return;
    }
    self.XMLHttpRequest = MockerXHR;
}
exports.patchXHR = patchXHR;
// only `readystatechange` event and progress events are need to be dispatched
var EVENTS_LIST = [
    'readystatechange',
    'loadstart',
    'progress',
    'load',
    'loadend',
];
var ExtandableXHR = _1.extensify(XMLHttpRequest);
var MockerXHR = (function (_super) {
    tslib_1.__extends(MockerXHR, _super);
    function MockerXHR() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // record request headers via `setRequestHeader` method
        _this._requestHeaders = new Headers();
        return _this;
    }
    MockerXHR.prototype.setRequestHeader = function (header, value) {
        _super.prototype.setRequestHeader.call(this, header, value);
        this._requestHeaders.append(header, value);
    };
    MockerXHR.prototype.getResponseHeader = function (header) {
        if (!this._responseHeaders) {
            return _super.prototype.getResponseHeader.call(this, header);
        }
        return this._responseHeaders.get(header);
    };
    MockerXHR.prototype.getAllResponseHeaders = function () {
        if (!this._responseHeaders) {
            return _super.prototype.getAllResponseHeaders.call(this);
        }
        var results = [];
        // https://xhr.spec.whatwg.org/#dom-xmlhttprequest-getallresponseheaders
        var seperator = String.fromCharCode(0x3A) + String.fromCharCode(0x20);
        var linebreaker = String.fromCharCode(0x0D) + String.fromCharCode(0x0A);
        this._responseHeaders.forEach(function (value, name) {
            results.push([name, value].join(seperator));
        });
        return results.join(linebreaker);
    };
    MockerXHR.prototype.overrideMimeType = function (mime) {
        /* istanbul ignore if */
        if (!_super.prototype.overrideMimeType) {
            return;
        }
        _super.prototype.overrideMimeType.call(this, mime);
        this._responseMIME = mime;
    };
    // using rest parameter `method, url, ...rest` here raises a typescript error report, see:
    // https://github.com/Microsoft/TypeScript/issues/4130
    MockerXHR.prototype.open = function (method, url, async, user, password) {
        _super.prototype.open.call(this, method, url, async, user, password);
        this._method = method;
        this._url = url;
    };
    MockerXHR.prototype.send = function (data) {
        var _this = this;
        if (this.readyState !== this.OPENED) {
            throw new Error("Failed to execute 'send' on 'XMLHttpRequest': The object's state must be OPENED.");
        }
        this._mockFetch(data).then(function (result) {
            if (result) {
                // `event.respondWith` called
                // resolve with mock response
                _this._processResponse(result);
            }
            else {
                // send real XMLHttpRequest
                _super.prototype.send.call(_this, data);
            }
        });
    };
    MockerXHR.prototype._mockFetch = function (data) {
        // GET|HEAD requests cannot include body
        // set body to `null` will raise a TypeMismatchError in IE Edge
        var body = (this._method === 'GET' || this._method === 'HEAD') ? undefined : data;
        var credentials = this.withCredentials ? 'include' : 'omit';
        var request = new Request(this._url, {
            body: body, credentials: credentials,
            method: this._method,
            headers: this._requestHeaders,
        });
        return dispatch_fetch_event_1.dispatchFetchEvent(request);
    };
    MockerXHR.prototype._processResponse = function (response) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._responseMIME) {
                            // apply `overrideMimeType`
                            response.headers.set('content-type', this._responseMIME);
                        }
                        return [4 /*yield*/, parseResponse(response, this.responseType)];
                    case 1:
                        result = _a.sent();
                        this._responseHeaders = response.headers;
                        // pretend this request is DONE
                        this._setProperty('readyState', this.DONE);
                        this._setProperty('responseURL', response.url);
                        this._setProperty('status', response.status);
                        this._setProperty('statusText', response.statusText);
                        this._setProperty('response', result);
                        if (!this.responseType || this.responseType === 'text') {
                            this._setProperty('responseText', result);
                        }
                        if (this.responseType === 'document') {
                            this._setProperty('responseXML', result);
                        }
                        this._dispatchEvents();
                        return [2 /*return*/];
                }
            });
        });
    };
    MockerXHR.prototype._setProperty = function (name, value) {
        // in IE & Safari, these property are internally read-only on native XHR instance
        // assign to patched XHR, as a trade-off
        Object.defineProperty(this, name, {
            value: value,
            writable: false,
            enumerable: true,
            configurable: true,
        });
    };
    // events handlers
    MockerXHR.prototype._dispatchEvents = function () {
        var _this = this;
        EVENTS_LIST.forEach(function (type) {
            var event = create_event_1.createEvent(type);
            if (type !== 'readystatechange') {
                // progress event
                event.total = event.loaded = 1;
            }
            // Caveat: `this` & `event.target` are still the native one
            _this.dispatchEvent(event);
        });
    };
    return MockerXHR;
}(ExtandableXHR));
// marked with `mockerPatched` symbol
MockerXHR.mockerPatched = true;
// keep a native reference
MockerXHR.native = XMLHttpRequest;
/**
 * Parse response with the specified `responseType`,
 * return `null` if any error occurs, see:
 * https://xhr.spec.whatwg.org/#the-response-attribute
 */
function parseResponse(response, responseType) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var res, _a, text, parser, e_1;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 12, , 13]);
                    res = response.clone();
                    _a = responseType;
                    switch (_a) {
                        case '': return [3 /*break*/, 1];
                        case 'text': return [3 /*break*/, 1];
                        case 'json': return [3 /*break*/, 3];
                        case 'blob': return [3 /*break*/, 5];
                        case 'arraybuffer': return [3 /*break*/, 7];
                        case 'document': return [3 /*break*/, 9];
                    }
                    return [3 /*break*/, 11];
                case 1: return [4 /*yield*/, res.text()];
                case 2: return [2 /*return*/, _b.sent()];
                case 3: return [4 /*yield*/, res.json()];
                case 4: return [2 /*return*/, _b.sent()];
                case 5: return [4 /*yield*/, res.blob()];
                case 6: return [2 /*return*/, _b.sent()];
                case 7: return [4 /*yield*/, res.arrayBuffer()];
                case 8: return [2 /*return*/, _b.sent()];
                case 9: return [4 /*yield*/, res.text()];
                case 10:
                    text = _b.sent();
                    parser = new DOMParser();
                    return [2 /*return*/, parser.parseFromString(text, getDocumentMIME(res))];
                case 11: return [3 /*break*/, 13];
                case 12:
                    e_1 = _b.sent();
                    return [3 /*break*/, 13];
                case 13: return [2 /*return*/, null];
            }
        });
    });
}
function getDocumentMIME(res) {
    var contentType = res.headers.get('content-type');
    /* istanbul ignore if */
    if (!contentType) {
        return 'text/html';
    }
    // strip charset
    return contentType.replace(/;.*/, '');
}
//# sourceMappingURL=patch-xhr.js.map