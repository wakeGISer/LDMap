/**
 * Make the un-extendable classes great again
 *
 * Notes:
 * - Main concepts:
 *   1. The best way to make another native class is to extend native class
 *      with overriding some methods. However, extending the native sometimes
 *      raises an error: <Failed to construct ${Native}: Please use the 'new' operator,
 *      this DOM object constructor cannot be called as a function.>
 *   2. So we should extend `Native` in some ways that are not constructing
 *      new instance with `Native.call(this)`:
 *      2.1. Look back to JavaScript inheritance, no matter which method we choose to
 *           use, we are almost doing the same thing: let the execution context of
 *           `SuperClass.prototype.method` be the instance of `SubClass`.
 *      1.2. Thus if we bind `Native.prototype.method` with a native instance,
 *           we can be free to invoke all methods in prototype! Then attaching these
 *           methods to the `Extendable.prototype`, the instances of `Extendable` will act
 *           as if they're real native instances!
 *
 * - Implementation of `Extendable`:
 *   1. Create a normal class with `this._native` pointing to a native instance,
 *   2. Iterate through the descriptors of `Native.prototype`:
 *      2.1. If the property is a primitive value, do nothing,
 *      2.2. If the property is an accessor, bind `get` and `set` with `this._native`,
 *      2.3. If the property is a function, bind it with `this._native`,
 *      2.4. Copy the descriptor to `Extendable.prototype`
 *   3. Iterate through the descriptors of `Native`, copy them to `Extendable` as
 *      static methods.
 */
"use strict";
function extensify(Native) {
    var Extendable = (function () {
        function Extendable() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._native = initNative.apply(void 0, args);
            checkLack(this._native);
        }
        return Extendable;
    }());
    function initNative() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0) {
            return new Native();
        }
        return new (Native.bind.apply(Native, [void 0].concat(args)))();
    }
    var checked = false;
    /* istanbul ignore next: safari only */
    function checkLack(instance) {
        if (checked) {
            return;
        }
        var _loop_1 = function (prop) {
            if (!Extendable.prototype.hasOwnProperty(prop)) {
                Object.defineProperty(Extendable.prototype, prop, {
                    get: function () {
                        return this._native[prop];
                    },
                    set: function (value) {
                        this._native[prop] = value;
                        return value;
                    },
                    enumerable: true,
                    configurable: true,
                });
            }
        };
        // safari 9- only have methods on `XMLHttpRequest.prototype`
        // so we need copy properties from an instance
        for (var prop in instance) {
            _loop_1(prop);
        }
    }
    // copy all static properties
    // safari 9- will include a "prototype" property on XMLHttpRequest
    try {
        Object.keys(Native).forEach(function (prop) {
            Object.defineProperty(Extendable, prop, Object.getOwnPropertyDescriptor(Native, prop));
        });
    }
    catch (e) { }
    // delegate all unset properties to `_native`
    (function mapPrototypeMethods(source, target) {
        if (source === void 0) { source = Native.prototype; }
        if (target === void 0) { target = Extendable.prototype; }
        if (source.constructor === Object) {
            // exit recursion
            return;
        }
        Object.keys(source).forEach(function (prop) {
            /* istanbul ignore if */
            if (target.hasOwnProperty(prop)) {
                return;
            }
            var descriptor = Object.getOwnPropertyDescriptor(source, prop);
            if (descriptor.get || descriptor.set) {
                descriptor.get = function getNative() {
                    return this._native[prop];
                };
                descriptor.set = function setNative(value) {
                    this._native[prop] = value;
                    return value;
                };
            }
            else if (typeof descriptor.value === 'function') {
                // method
                var nativeFn_1 = descriptor.value;
                descriptor.value = function wrapped() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return nativeFn_1.apply(this._native, args);
                };
            }
            // enable overriding
            descriptor.configurable = true;
            Object.defineProperty(target, prop, descriptor);
        });
        // recursively look-up
        mapPrototypeMethods(Object.getPrototypeOf(source), target);
    })();
    return Extendable;
}
exports.extensify = extensify;
//# sourceMappingURL=extensify.js.map