"use strict";
var tslib_1 = require("tslib");
var mime = require("mime-component");
var httpStatus = require("statuses");
var _1 = require("../utils/");
var request_1 = require("./request");
var responseLog = _1.debug.scope('response');
var IS_IE_EDGE = /Edge/.test(navigator.userAgent);
var MockerResponse = (function () {
    function MockerResponse(_event) {
        this._event = _event;
        this.headers = new Headers({
            'X-Powered-By': 'ServiceMocker',
        });
        this._statusCode = 200;
        this._deferred = new _1.Defer();
        var _deferred = this._deferred;
        // everything within service worker should be asynchronous
        _event.respondWith(_deferred.promise);
    }
    /**
     * Sets the HTTP status for the response.
     *
     * @chainable
     * @param code Status code
     */
    MockerResponse.prototype.status = function (code) {
        this._statusCode = code;
        return this;
    };
    /**
     * Sets the Content-Type HTTP header to the MIME type.
     * If the given MIME doesn't contain '/' character,
     * use `mime.lookup(type)` to obtain MIME type.
     *
     * @chainable
     * @param type MIME type
     */
    MockerResponse.prototype.type = function (type) {
        var contentType = type.indexOf('/') === -1 ? mime.lookup(type) : type;
        this.headers.set('content-type', contentType);
        return this;
    };
    /**
     * Send a JSON response.
     *
     * @param body Any JSON compatible type, including object, array, string, Boolean, or number.
     */
    MockerResponse.prototype.json = function (body) {
        this._body = JSON.stringify(body);
        if (!this.headers.has('content-type')) {
            this.type('json');
        }
        this.end();
    };
    /**
     * Sends the HTTP response.
     *
     * @param body Response body, one of Blob, ArrayBuffer, Object, or any primitive types
     */
    MockerResponse.prototype.send = function (body) {
        // don't parse native Response objects
        if (body instanceof Response) {
            this._body = body;
            return this.end();
        }
        var contentType = 'text';
        switch (typeof body) {
            case 'string':
                // follow the express style
                this._body = body;
                contentType = 'html';
                break;
            case 'boolean':
            case 'number':
            case 'object':
                if (body instanceof Blob) {
                    this._body = body;
                    contentType = body.type || 'bin';
                }
                else if (body instanceof ArrayBuffer) {
                    this._body = body;
                    contentType = 'bin';
                }
                else {
                    return this.json(body);
                }
                break;
        }
        if (!this.headers.has('content-type')) {
            this.type(contentType);
        }
        this.end();
    };
    /**
     * Set the response HTTP status code to statusCode and
     * send its status text representation as the response body.
     *
     * Equivalent to `res.status(code).send(statusText)`
     *
     * @param code Status code
     */
    MockerResponse.prototype.sendStatus = function (code) {
        var body = httpStatus[code] || JSON.stringify(code);
        this.type('text').status(code).send(body);
    };
    /**
     * End the response processing and pass the response to `fetchEvent.respondWith()`.
     * Simply call this method will end the response WITHOUT any data,
     * if you want to respond with data, use `res.send()` and `res.json()`.
     */
    MockerResponse.prototype.end = function () {
        // respond with body if it's a native Response object
        if (this._body instanceof Response) {
            return this._deferred.resolve(this._body);
        }
        var request = this._event.request;
        var responseBody = this._body;
        // leave body empty for null body status
        if (httpStatus.empty[this._statusCode]) {
            /* istanbul ignore if */
            if (IS_IE_EDGE) {
                responseLog.warn('using null body status in IE Edge may raise a `TypeMismatchError` Error');
            }
            responseBody = undefined;
        }
        // skip body for HEAD requests
        if (request.method === 'HEAD') {
            responseBody = undefined;
        }
        // set default contentType to 'text/plain', see
        // https://tools.ietf.org/html/rfc2045#section-5.2
        if (!this.headers.has('content-type')) {
            this.type('text');
        }
        var responseInit = {
            headers: this.headers,
            status: this._statusCode,
            statusText: httpStatus[this._statusCode] || JSON.stringify(this._statusCode),
        };
        var response = new Response(responseBody, responseInit);
        this._deferred.resolve(response);
    };
    MockerResponse.prototype.forward = function (input, init) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var request;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(input instanceof Request)) return [3 /*break*/, 1];
                        // forward native Request
                        request = new Request(input, init);
                        return [3 /*break*/, 4];
                    case 1:
                        if (!(input instanceof request_1.MockerRequest)) return [3 /*break*/, 2];
                        // forward MockerRequest
                        request = new Request(input._native, init);
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, concatRequest(this._event.request, input, init)];
                    case 3:
                        // create new Request
                        request = _a.sent();
                        _a.label = 4;
                    case 4:
                        // fetch will somehow consume the body
                        this._deferred.resolve(nativeFetch(request));
                        return [2 /*return*/];
                }
            });
        });
    };
    return MockerResponse;
}());
exports.MockerResponse = MockerResponse;
/**
 * Concat new request info with given old request
 */
function concatRequest(oldRequest, input, init) {
    if (init === void 0) { init = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var tempRequest, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    tempRequest = new Request(input, oldRequest);
                    if (!(!init.body && tempRequest.method !== 'GET' && tempRequest.method !== 'HEAD')) return [3 /*break*/, 2];
                    _a = init;
                    return [4 /*yield*/, bodyParser(oldRequest)];
                case 1:
                    _a.body = _b.sent();
                    _b.label = 2;
                case 2: return [2 /*return*/, new Request(tempRequest, init)];
            }
        });
    });
}
/**
 * Parse request body
 *
 * 1. If you're using github fetch polyfill, return the private member `_bodyInit`,
 * 2. Else parsing request body as blob.
 */
function bodyParser(request) {
    // handle github fetch polyfill
    /* istanbul ignore if */
    if (fetch.polyfill) {
        return request._bodyInit;
    }
    try {
        // always parse as blob
        return request.clone().blob();
    }
    catch (e) {
        /* istanbul ignore next */
        responseLog.warn('parsing request body failed, you may need to parse it manually', e);
    }
}
/**
 * Fetch with native `fetch`
 *
 * 1. If `fetch.mockerPatched` is found, it means you're running on
 *    legacy mode with fetch support, return with `fetch.native`.
 *
 * 2. Else if `XMLHttpRequest.mockerPatched` is found, you're possibly
 *    using a fetch polyfill, processing as the following:
 *    2.1. Reset `XMLHttpRequest` to native one `(patched)XMLHttpRequest.native`,
 *    2.2. Run fetch polyfill (with native XHR),
 *    2.3. Restore `XMLHttpRequest` to patched one,
 *    2.4. Return the fetch promise.
 *
 * 3. Or, you may be running in service worker context, return `fetch`.
 */
/* istanbul ignore next */
function nativeFetch(input, init) {
    var globalContext = self;
    var fetch = globalContext.fetch, XHR = globalContext.XMLHttpRequest;
    // native fetch
    if (fetch.mockerPatched) {
        return fetch.native(input, init);
    }
    // fetch polyfills
    if (XHR && XHR.mockerPatched) {
        // restore native...
        globalContext.XMLHttpRequest = XHR.native;
        // do a native fetch
        var promise = fetch(input, init);
        // replace with our fetch
        globalContext.XMLHttpRequest = XHR;
        return promise;
    }
    return fetch(input, init);
}
//# sourceMappingURL=response.js.map