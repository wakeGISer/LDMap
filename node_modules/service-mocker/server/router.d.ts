/// <reference types="service_worker_api" />
import { MockerRequest } from './request';
import { MockerResponse } from './response';
export declare type RoutePath = string | RegExp;
export declare type RouteCallback = (request: MockerRequest, response: MockerResponse) => void;
export interface IRouterMatcher<T> {
    /**
     * Register a routing
     *
     * @param path An express style route path.
     * @param callback A function that will be invoked with `request` and `response`,
     *                 if the second argument is provided with a non-function value,
     *                 then the value will be regarded as response body.
     */
    (path: RoutePath, callback: RouteCallback): T;
    /**
     * Register a routing
     *
     * @param path An express style route path.
     * @param responseBody The response body to be sent.
     */
    (path: RoutePath, responseBody: any): T;
}
export interface ISubRouterMatcher<T> {
    /**
     * Register a routing to current scope
     *
     * @param callback A function that will be invoked with `request` and `response`,
     *                 if the second argument is provided with a non-function value,
     *                 then the value will be regarded as response body.
     */
    (callback: RouteCallback): T;
    /**
     * Register a routing to current scope
     *
     * @param responseBody The response body to be sent.
     */
    (responseBody: any): T;
}
export interface IMockerRouter {
    readonly baseURL: string;
    scope(path?: string): IMockerRouter;
    route(path: RoutePath): ISubRouter;
    all: IRouterMatcher<this>;
    get: IRouterMatcher<this>;
    post: IRouterMatcher<this>;
    put: IRouterMatcher<this>;
    head: IRouterMatcher<this>;
    delete: IRouterMatcher<this>;
    options: IRouterMatcher<this>;
}
export interface ISubRouter {
    all: ISubRouterMatcher<this>;
    get: ISubRouterMatcher<this>;
    post: ISubRouterMatcher<this>;
    put: ISubRouterMatcher<this>;
    head: ISubRouterMatcher<this>;
    delete: ISubRouterMatcher<this>;
    options: ISubRouterMatcher<this>;
}
export interface MockerRouter extends IMockerRouter {
}
export declare class MockerRouter implements IMockerRouter {
    static routers: Array<MockerRouter>;
    readonly baseURL: string;
    private _origin;
    private _basePath;
    private _rules;
    constructor(baseURL?: string);
    /**
     * Create a new router with the given path as scope.
     */
    scope(path?: string): MockerRouter;
    base(path?: string): MockerRouter;
    /**
     * Create a scoped router with the given path as
     * route path for every routing method.
     */
    route(path: RoutePath): SubRouter;
    /**
     * Register a new routing to current router
     *
     * @param method HTTP method
     * @param path Routing path rule
     * @param callback Routing callback handler
     */
    register(method: string, path: RoutePath, callback: any): this;
    /**
     * Match the proper routing, return `true` if rule matched
     *
     * @param event Fetch event
     */
    match(event: FetchEvent): boolean;
}
export interface SubRouter extends ISubRouter {
}
export declare class SubRouter implements ISubRouter {
    private _router;
    private _path;
    constructor(_router: MockerRouter, _path: RoutePath);
    /**
     * Register a new scoped routing
     * @param method HTTP method
     * @param callback Routing callback handler
     */
    register(method: string, callback: any): this;
}
